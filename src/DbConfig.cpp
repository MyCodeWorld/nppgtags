/**
 *  \file
 *  \brief  GTags database config class
 *
 *  \author  Pavel Nedev <pg.nedev@gmail.com>
 *
 *  \section COPYRIGHT
 *  Copyright(C) 2015 Pavel Nedev
 *
 *  \section LICENSE
 *  This program is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License version 2 as published
 *  by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 *  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 *  for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program.  If not, see <http://www.gnu.org/licenses/>.
 */


#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include "Common.h"
#include "DbConfig.h"
#include "GTags.h"


namespace GTags
{

const TCHAR DbConfig::cCfgFileName[]    = PLUGIN_NAME _T(".cfg");

const TCHAR DbConfig::cDefaultParser[]  = _T("default");
const TCHAR DbConfig::cCtagsParser[]    = _T("ctags");
const TCHAR DbConfig::cPygmentsParser[] = _T("pygments");

const TCHAR* DbConfig::cParsers[DbConfig::PARSER_LIST_END] = {
    DbConfig::cDefaultParser,
    DbConfig::cCtagsParser,
    DbConfig::cPygmentsParser
};

const TCHAR DbConfig::cInfo[] =
        _T("# Database configuration file for Notepad++ ") PLUGIN_NAME _T(" plugin\n")
        _T("# This file is automatically generated and will be overwritten")
        _T(" on next ") PLUGIN_NAME _T(" config\n");

const TCHAR DbConfig::cParserKey[]      = _T("Parser = ");
const TCHAR DbConfig::cAutoUpdateKey[]  = _T("AutoUpdate = ");
const TCHAR DbConfig::cUseLibraryKey[]  = _T("UseLibrary = ");
const TCHAR DbConfig::cLibraryPathKey[] = _T("LibraryPath = ");


/**
 *  \brief
 */
DbConfig::DbConfig()
{
    SetDefaults();
}


/**
 *  \brief
 */
void DbConfig::SetDefaults()
{
    _parserIdx = DEFAULT_PARSER;
    _autoUpdate = true;
    _useLibDb = false;
    _libDbPaths.clear();
}


/**
 *  \brief
 */
bool DbConfig::LoadFromFolder(const CPath& cfgFileFolder)
{
    SetDefaults();

    CPath cfgFile(cfgFileFolder);
    cfgFile += cCfgFileName;

    if (!cfgFile.Exists())
        return false;

    FILE* fp;
    _tfopen_s(&fp, cfgFile.C_str(), _T("rt"));
    if (fp == NULL)
        return false;

    TCHAR line[8192];
    while (_fgetts(line, _countof(line), fp))
    {
        // Comment or empty line
        if (line[0] == _T('#') || line[0] == _T('\n'))
            continue;

        // Strip newline from the end of the line
        line[_tcslen(line) - 1] = 0;

        if (!_tcsncmp(line, cParserKey, _countof(cParserKey) - 1))
        {
            unsigned pos = _countof(cParserKey) - 1;
            if (!_tcsncmp(&line[pos], cCtagsParser, _countof(cCtagsParser) - 1))
                _parserIdx = CTAGS_PARSER;
            else if (!_tcsncmp(&line[pos], cPygmentsParser, _countof(cPygmentsParser) - 1))
                _parserIdx = PYGMENTS_PARSER;
            else
                _parserIdx = DEFAULT_PARSER;
        }
        else if (!_tcsncmp(line, cAutoUpdateKey, _countof(cAutoUpdateKey) - 1))
        {
            unsigned pos = _countof(cAutoUpdateKey) - 1;
            if (!_tcsncmp(&line[pos], _T("yes"), _countof(_T("yes")) - 1))
                _autoUpdate = true;
            else
                _autoUpdate = false;
        }
        else if (!_tcsncmp(line, cUseLibraryKey, _countof(cUseLibraryKey) - 1))
        {
            unsigned pos = _countof(cUseLibraryKey) - 1;
            if (!_tcsncmp(&line[pos], _T("yes"), _countof(_T("yes")) - 1))
                _useLibDb = true;
            else
                _useLibDb = false;
        }
        else if (!_tcsncmp(line, cLibraryPathKey, _countof(cLibraryPathKey) - 1))
        {
            unsigned pos = _countof(cLibraryPathKey) - 1;
            DbPathsFromBuf(&line[pos], _T(";"));
        }
        else
        {
            SetDefaults();
            fclose(fp);
            return false;
        }
    }

    fclose(fp);

    return true;
}


/**
 *  \brief
 */
bool DbConfig::SaveToFolder(const CPath& cfgFileFolder) const
{
    CPath cfgFile(cfgFileFolder);
    cfgFile += cCfgFileName;

    FILE* fp;
    _tfopen_s(&fp, cfgFile.C_str(), _T("wt"));
    if (fp == NULL)
        return false;

    CText libDbPaths;
    DbPathsToBuf(libDbPaths, _T(';'));

    bool success = false;
    if (_ftprintf_s(fp, _T("%s\n"), cInfo) > 0)
    if (_ftprintf_s(fp, _T("%s%s\n"), cParserKey, Parser()) > 0)
    if (_ftprintf_s(fp, _T("%s%s\n"), cAutoUpdateKey, (_autoUpdate ? _T("yes") : _T("no"))) > 0)
    if (_ftprintf_s(fp, _T("%s%s\n"), cUseLibraryKey, (_useLibDb ? _T("yes") : _T("no"))) > 0)
    if (_ftprintf_s(fp, _T("%s%s\n"), cLibraryPathKey, libDbPaths.C_str()) > 0)
        success = true;

    fclose(fp);
    return success;
}


/**
 *  \brief
 */
void DbConfig::DbPathsFromBuf(TCHAR* buf, const TCHAR* separators)
{
    TCHAR* pTmp = NULL;
    for (TCHAR* ptr = _tcstok_s(buf, separators, &pTmp); ptr; ptr = _tcstok_s(NULL, separators, &pTmp))
    {
        CPath db(ptr);
        db.StripTrailingSpaces();
        if (db.Exists())
            _libDbPaths.push_back(db);
    }
}


/**
 *  \brief
 */
void DbConfig::DbPathsToBuf(CText& buf, TCHAR separator) const
{
    if (!_libDbPaths.size())
        return;

    buf += _libDbPaths[0];

    for (unsigned i = 1; i < _libDbPaths.size(); ++i)
    {
        buf += separator;
        buf += _libDbPaths[i];
    }
}


/**
 *  \brief
 */
const DbConfig& DbConfig::operator=(const DbConfig& cfg)
{
    if (this != &cfg)
    {
        _parserIdx  = cfg._parserIdx;
        _autoUpdate = cfg._autoUpdate;
        _useLibDb   = cfg._useLibDb;
        _libDbPaths = cfg._libDbPaths;
    }

    return *this;
}


/**
 *  \brief
 */
bool DbConfig::operator==(const DbConfig& cfg) const
{
    if (this == &cfg)
        return true;

    return (_parserIdx == cfg._parserIdx && _autoUpdate == cfg._autoUpdate &&
            _useLibDb == cfg._useLibDb && _libDbPaths == cfg._libDbPaths);
}

} // namespace GTags
