/**
 *  \file
 *  \brief  GTags config class
 *
 *  \author  Pavel Nedev <pg.nedev@gmail.com>
 *
 *  \section COPYRIGHT
 *  Copyright(C) 2015-2016 Pavel Nedev
 *
 *  \section LICENSE
 *  This program is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License version 2 as published
 *  by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 *  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 *  for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program.  If not, see <http://www.gnu.org/licenses/>.
 */


#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include "Common.h"
#include "GTagsConfig.h"
#include "GTags.h"


namespace GTags
{

const TCHAR GTagsConfig::cCfgFileName[]     = PLUGIN_NAME _T(".cfg");

const TCHAR GTagsConfig::cDefaultParser[]   = _T("default");
const TCHAR GTagsConfig::cCtagsParser[]     = _T("ctags");
const TCHAR GTagsConfig::cPygmentsParser[]  = _T("pygments");

const TCHAR* GTagsConfig::cParsers[GTagsConfig::PARSER_LIST_END] = {
    GTagsConfig::cDefaultParser,
    GTagsConfig::cCtagsParser,
    GTagsConfig::cPygmentsParser
};

const TCHAR GTagsConfig::cInfo[] =
        _T("# Configuration file for Notepad++ ") PLUGIN_NAME _T(" plugin\n")
        _T("# This file is automatically generated and will be overwritten")
        _T(" on next ") PLUGIN_NAME _T(" config\n");

const TCHAR GTagsConfig::cParserKey[]       = _T("Parser = ");
const TCHAR GTagsConfig::cAutoUpdateKey[]   = _T("AutoUpdate = ");
const TCHAR GTagsConfig::cUseLibraryKey[]   = _T("UseLibrary = ");
const TCHAR GTagsConfig::cLibraryPathKey[]  = _T("LibraryPath = ");
const TCHAR GTagsConfig::cRECacheKey[]      = _T("RegExpEn = ");
const TCHAR GTagsConfig::cMCCacheKey[]      = _T("MatchCaseEn = ");


/**
 *  \brief
 */
GTagsConfig::GTagsConfig()
{
    SetDefaults();
}


/**
 *  \brief
 */
void GTagsConfig::SetDefaults()
{
    _parserIdx = DEFAULT_PARSER;
    _autoUpdate = true;
    _useLibDb = false;
    _libDbPaths.clear();
    _reCache = false;
    _mcCache = true;
}


/**
 *  \brief
 */
bool GTagsConfig::LoadFromFolder(const CPath& cfgFileFolder, bool isGenericCfg)
{
    SetDefaults();

    CPath cfgFile(cfgFileFolder);
    cfgFile += cCfgFileName;

    if (!cfgFile.Exists())
        return false;

    FILE* fp;
    _tfopen_s(&fp, cfgFile.C_str(), _T("rt"));
    if (fp == NULL)
        return false;

    TCHAR line[8192];
    while (_fgetts(line, _countof(line), fp))
    {
        // Comment or empty line
        if (line[0] == _T('#') || line[0] == _T('\n'))
            continue;

        // Strip newline from the end of the line
        line[_tcslen(line) - 1] = 0;

        if (!_tcsncmp(line, cParserKey, _countof(cParserKey) - 1))
        {
            unsigned pos = _countof(cParserKey) - 1;
            if (!_tcsncmp(&line[pos], cCtagsParser, _countof(cCtagsParser) - 1))
                _parserIdx = CTAGS_PARSER;
            else if (!_tcsncmp(&line[pos], cPygmentsParser, _countof(cPygmentsParser) - 1))
                _parserIdx = PYGMENTS_PARSER;
            else
                _parserIdx = DEFAULT_PARSER;
        }
        else if (!_tcsncmp(line, cAutoUpdateKey, _countof(cAutoUpdateKey) - 1))
        {
            unsigned pos = _countof(cAutoUpdateKey) - 1;
            if (!_tcsncmp(&line[pos], _T("yes"), _countof(_T("yes")) - 1))
                _autoUpdate = true;
            else
                _autoUpdate = false;
        }
        else if (!_tcsncmp(line, cUseLibraryKey, _countof(cUseLibraryKey) - 1))
        {
            unsigned pos = _countof(cUseLibraryKey) - 1;
            if (!_tcsncmp(&line[pos], _T("yes"), _countof(_T("yes")) - 1))
                _useLibDb = true;
            else
                _useLibDb = false;
        }
        else if (!_tcsncmp(line, cLibraryPathKey, _countof(cLibraryPathKey) - 1))
        {
            unsigned pos = _countof(cLibraryPathKey) - 1;
            DbPathsFromBuf(&line[pos], _T(";"));
        }
        else if (isGenericCfg && !_tcsncmp(line, cRECacheKey, _countof(cRECacheKey) - 1))
        {
            unsigned pos = _countof(cRECacheKey) - 1;
            if (!_tcsncmp(&line[pos], _T("yes"), _countof(_T("yes")) - 1))
                _reCache = true;
            else
                _reCache = false;
        }
        else if (isGenericCfg && !_tcsncmp(line, cMCCacheKey, _countof(cMCCacheKey) - 1))
        {
            unsigned pos = _countof(cMCCacheKey) - 1;
            if (!_tcsncmp(&line[pos], _T("yes"), _countof(_T("yes")) - 1))
                _mcCache = true;
            else
                _mcCache = false;
        }
        else
        {
            SetDefaults();
            fclose(fp);
            return false;
        }
    }

    fclose(fp);

    return true;
}


/**
 *  \brief
 */
bool GTagsConfig::SaveToFolder(const CPath& cfgFileFolder, bool isGenericCfg) const
{
    CPath cfgFile(cfgFileFolder);
    cfgFile += cCfgFileName;

    FILE* fp;
    _tfopen_s(&fp, cfgFile.C_str(), _T("wt"));
    if (fp == NULL)
        return false;

    CText libDbPaths;
    DbPathsToBuf(libDbPaths, _T(';'));

    bool success = false;
    if (_ftprintf_s(fp, _T("%s\n"), cInfo) > 0)
    if (_ftprintf_s(fp, _T("%s%s\n"), cParserKey, Parser()) > 0)
    if (_ftprintf_s(fp, _T("%s%s\n"), cAutoUpdateKey, (_autoUpdate ? _T("yes") : _T("no"))) > 0)
    if (_ftprintf_s(fp, _T("%s%s\n"), cUseLibraryKey, (_useLibDb ? _T("yes") : _T("no"))) > 0)
    if (_ftprintf_s(fp, _T("%s%s\n"), cLibraryPathKey, libDbPaths.C_str()) > 0)
        success = true;

    if (isGenericCfg)
    {
        success = false;
        if (_ftprintf_s(fp, _T("\n%s%s\n"), cRECacheKey, (_reCache ? _T("yes") : _T("no"))) > 0)
        if (_ftprintf_s(fp, _T("%s%s\n"), cMCCacheKey, (_mcCache ? _T("yes") : _T("no"))) > 0)
            success = true;
    }

    fclose(fp);
    return success;
}


/**
 *  \brief
 */
void GTagsConfig::DbPathsFromBuf(TCHAR* buf, const TCHAR* separators)
{
    TCHAR* pTmp = NULL;
    for (TCHAR* ptr = _tcstok_s(buf, separators, &pTmp); ptr; ptr = _tcstok_s(NULL, separators, &pTmp))
    {
        CPath db(ptr);
        db.StripTrailingSpaces();
        if (db.Exists())
            _libDbPaths.push_back(db);
    }
}


/**
 *  \brief
 */
void GTagsConfig::DbPathsToBuf(CText& buf, TCHAR separator) const
{
    if (!_libDbPaths.size())
        return;

    buf += _libDbPaths[0];

    for (unsigned i = 1; i < _libDbPaths.size(); ++i)
    {
        buf += separator;
        buf += _libDbPaths[i];
    }
}


/**
 *  \brief
 */
const GTagsConfig& GTagsConfig::operator=(const GTagsConfig& cfg)
{
    if (this != &cfg)
    {
        _parserIdx  = cfg._parserIdx;
        _autoUpdate = cfg._autoUpdate;
        _useLibDb   = cfg._useLibDb;
        _libDbPaths = cfg._libDbPaths;
    }

    return *this;
}


/**
 *  \brief
 */
bool GTagsConfig::operator==(const GTagsConfig& cfg) const
{
    if (this == &cfg)
        return true;

    return (_parserIdx == cfg._parserIdx && _autoUpdate == cfg._autoUpdate &&
            _useLibDb == cfg._useLibDb && _libDbPaths == cfg._libDbPaths);
}

} // namespace GTags
